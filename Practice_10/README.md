


## Task1

<img width="1185" height="139" alt="image" src="https://github.com/user-attachments/assets/ae511bec-788d-4f30-90cc-6cdbe2c611f2" />


## Task2

<img width="416" height="137" alt="image" src="https://github.com/user-attachments/assets/e2ad9151-f1ca-4697-b7dc-766d2bdeec29" />


## Task3

<img width="464" height="285" alt="image" src="https://github.com/user-attachments/assets/70b9e4ae-fc87-4e4d-b8e1-4f527bf19123" />


## Task4

<img width="592" height="420" alt="image" src="https://github.com/user-attachments/assets/21993c57-8fe3-41c0-a6b5-0b7e4f658d2e" />



# Контрольные вопросы


1. В чём отличие измерения времени выполнения от профилирования?


Ответ: Измерение времени выполнения показывает, сколько времени программа работает в целом или на отдельных участках. Профилирование идёт глубже и показывает, где именно тратится время: какие функции самые медленные и где возникают задержки.


2. Какие виды узких мест характерны для CPU, GPU и распределённых программ?


Ответ: Для CPU это может быть ограниченное количество ядер, частые ветвления и ожидание памяти. Для GPU - медленный доступ к памяти, плохая загрузка потоков и лишние копирования данных. В распределённых программах узким местом чаще всего становится обмен данными между узлами и задержки сети.


3. Почему увеличение числа потоков или процессов не всегда приводит к ускорению?
   

Ответ: Потому что растут накладные расходы на создание, синхронизацию и обмен данными. Кроме того, всегда есть часть программы, которая выполняется последовательно и не может быть распараллелена.


4. Как законы Амдала и Густафсона применяются при анализе масштабируемости?
   

Ответ: Закон Амдала показывает, что ускорение ограничено долей последовательного кода и бесконечного ускорения добиться нельзя. Закон Густафсона говорит, что при увеличении размера задачи параллельная часть растёт, и масштабируемость может быть лучше на больших данных.


5. Какие факторы наиболее критичны для производительности гибридных приложений?


Ответ: Критичны правильное распределение работы между CPU и GPU, минимизация передачи данных между ними и эффективное использование памяти. Также важно учитывать баланс нагрузки, чтобы ни CPU, ни GPU не простаивали.


### Сборка

!g++ -fopenmp task1_openmp.cpp -o task1_openmp

!nvcc task2_cuda.cu -o task2_cuda

!nvcc task3_hybrid.cu -o task3_hybrid

!mpicxx task4_mpi.cpp -o task4_mpi

### Запуск

!./task1_openmp

!./task2_cuda

!./task3_hybrid

!mpirun --allow-run-as-root --oversubscribe -np 2 ./task4_mpi
